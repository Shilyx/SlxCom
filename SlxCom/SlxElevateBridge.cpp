/*
 *  @file  : SlxElevateBridge.cpp
 *  @author: luteng
 *  @date  : 2015-08-07 17:41:24.764
 *  @note  : Generated by SlxTemplates
 */

#include "SlxElevateBridge.h"
#include <Shlwapi.h>

#define BridgeVersion TEXT("1.0@20150807")
#define CLASS_NAME TEXT("__SlxElevateBridgeWindow")

extern HINSTANCE g_hinstDll;    // SlxCom.cpp

enum
{
    WM_TO_BRIDGE_INFO = WM_USER + 65,
};

struct TaskDiscription
{
    TCHAR szCommand[MAX_PATH];
    TCHAR szArguments[4096];
    TCHAR szCurrentDirectory[MAX_PATH];
    int nShowCmd;
};

static BOOL NeedElevated()
{
    OSVERSIONINFO osi = { sizeof(osi) };

    GetVersionEx(&osi);

    if (osi.dwMajorVersion < 6)
    {
        return FALSE;
    }

    BOOL bIsElevated = FALSE;
    HANDLE hToken = NULL;

    if (OpenProcessToken(GetCurrentProcess(), TOKEN_QUERY, &hToken))
    {
        DWORD dwReturnLength = 0;
        struct
        {
            DWORD TokenIsElevated;
        } te;

        if (GetTokenInformation(hToken, (TOKEN_INFORMATION_CLASS)20, &te, sizeof(te), &dwReturnLength))
        {
            if (dwReturnLength == sizeof(te))
            {
                bIsElevated = !!te.TokenIsElevated;
            }
        }

        CloseHandle(hToken);
    }

    return !bIsElevated;
}

static HWND GetBridgeHandle()
{
    return FindWindow(CLASS_NAME, BridgeVersion);
}

static void GetTaskStorePath(const ULARGE_INTEGER &uliTaskId, TCHAR szPath[], int nBufferSize)
{
    wnsprintf(szPath, nBufferSize, TEXT("Software\\slx_tmp\\tasks\\%s\\%08x_%08x"), BridgeVersion, uliTaskId.HighPart, uliTaskId.LowPart);
}

static ULARGE_INTEGER MakeTask(LPCWSTR lpCommand, LPCWSTR lpArguments, LPCWSTR lpDirectory, int nShowCmd)
{
    ULARGE_INTEGER uliTaskId = { 0 };
    GUID guid = { 0 };
    TCHAR szRegPath[1024];

    if (lpCommand == NULL)
    {
        lpCommand = L"";
    }

    if (lpArguments == NULL)
    {
        lpArguments = L"";
    }

    if (lpDirectory == NULL)
    {
        lpDirectory = L"";
    }

    UuidCreate(&guid);
    uliTaskId.HighPart = GetTickCount();
    uliTaskId.LowPart = guid.Data1;

    GetTaskStorePath(uliTaskId, szRegPath, RTL_NUMBER_OF(szRegPath));

    HKEY hKey = NULL;

    if (RegCreateKeyEx(HKEY_CURRENT_USER, szRegPath, 0, NULL, REG_OPTION_VOLATILE, KEY_SET_VALUE, NULL, &hKey, NULL) == ERROR_SUCCESS)
    {
        RegSetValueExW(hKey, L"cmd", 0, REG_SZ, (const BYTE *)lpCommand, (lstrlenW(lpCommand) + 1) * sizeof(WCHAR));
        RegSetValueExW(hKey, L"arg", 0, REG_SZ, (const BYTE *)lpArguments, (lstrlenW(lpArguments) + 1) * sizeof(WCHAR));
        RegSetValueExW(hKey, L"dir", 0, REG_SZ, (const BYTE *)lpDirectory, (lstrlenW(lpDirectory) + 1) * sizeof(WCHAR));
        RegSetValueExW(hKey, L"sw", 0, REG_DWORD, (const BYTE *)&nShowCmd, sizeof(nShowCmd));

        RegCloseKey(hKey);

        return uliTaskId;
    }

    return ULARGE_INTEGER();
}

static void DeleteTask(const ULARGE_INTEGER &uliTaskId)
{
    TCHAR szRegPath[1024];

    GetTaskStorePath(uliTaskId, szRegPath, RTL_NUMBER_OF(szRegPath));
    RegDeleteKey(HKEY_CURRENT_USER, szRegPath);
}

BOOL StartBridgeWithTaskId(const ULARGE_INTEGER &uliTaskId)
{
    extern HINSTANCE g_hinstDll;

    TCHAR szRundll32[MAX_PATH] = TEXT("");
    TCHAR szDllPath[MAX_PATH] = TEXT("");
    TCHAR szArguments[MAX_PATH + 20] = TEXT("");

    GetSystemDirectory(szRundll32, RTL_NUMBER_OF(szRundll32));
    PathAppend(szRundll32, TEXT("\\rundll32.exe"));

    GetModuleFileName(g_hinstDll, szDllPath, RTL_NUMBER_OF(szDllPath));
    PathQuoteSpaces(szDllPath);

    wnsprintf(szArguments, RTL_NUMBER_OF(szArguments), TEXT("%s SlxElevateBridge %lu %lu"), szDllPath, uliTaskId.HighPart, uliTaskId.LowPart);

    return (int)ShellExecute(NULL, TEXT("runas"), szRundll32, szArguments, NULL, SW_SHOW) > 32;
}

BOOL WINAPI ElevateAndRunA(LPCSTR lpCommand, LPCSTR lpArguments, LPCSTR lpDirectory, int nShowCmd)
{
    WCHAR szCommand[MAX_PATH];
    WCHAR szArguments[4096];
    WCHAR szDirectory[MAX_PATH];

    wnsprintfW(szCommand, RTL_NUMBER_OF(szCommand), L"%hs", lpCommand);
    wnsprintfW(szArguments, RTL_NUMBER_OF(szArguments), L"%hs", lpArguments);
    wnsprintfW(szDirectory, RTL_NUMBER_OF(szDirectory), L"%hs", lpDirectory);

    return ElevateAndRunW(szCommand, szArguments, szDirectory, nShowCmd);
}

BOOL WINAPI ElevateAndRunW(LPCWSTR lpCommand, LPCWSTR lpArguments, LPCWSTR lpDirectory, int nShowCmd)
{
    static BOOL bNeedElevated = NeedElevated();

    if (!bNeedElevated)
    {
        return (int)ShellExecute(NULL, L"open", lpCommand, lpArguments, lpDirectory, nShowCmd) > 32;
    }

    ULARGE_INTEGER uliTaskId = MakeTask(lpCommand, lpArguments, lpDirectory, nShowCmd);

    if (uliTaskId.QuadPart == 0)
    {
        return FALSE;
    }

    HWND hBridge = GetBridgeHandle();

    if (IsWindow(hBridge))
    {
        return PostMessage(hBridge, WM_TO_BRIDGE_INFO, uliTaskId.HighPart, uliTaskId.LowPart);
    }

    if (!StartBridgeWithTaskId(uliTaskId))
    {
        DeleteTask(uliTaskId);
    }

    return TRUE;
}

namespace Bridge
{
    PROC GetProcAddressFromDll(LPCTSTR lpDllName, LPCSTR lpFunctionName)
    {
        HMODULE hModule = GetModuleHandle(lpDllName);

        if (hModule == NULL)
        {
            hModule = LoadLibrary(lpDllName);
        }

        if (hModule == NULL)
        {
            return NULL;
        }

        return GetProcAddress(hModule, lpFunctionName);
    }

    BOOL AddMessageToWindowMessageFilter(UINT uMsg)
    {
        static PROC pChangeWindowMessageFilter = GetProcAddressFromDll(TEXT("user32.dll"), "ChangeWindowMessageFilter");

        if (pChangeWindowMessageFilter != NULL)
        {
            return ((BOOL(WINAPI *)(UINT, DWORD))pChangeWindowMessageFilter)(uMsg, 1);
        }
        else
        {
            return FALSE;
        }
    }

    BOOL RegGetString(HKEY hKey, LPCTSTR lpRegPath, LPCTSTR lpRegValue, TCHAR szBuffer[], DWORD dwSize)
    {
        SHGetValue(hKey, lpRegPath, lpRegValue, NULL, szBuffer, &dwSize);

        return dwSize > 0;
    }

    BOOL DoBridgeJob(WPARAM wParam, LPARAM lParam)
    {
        static BOOL bNeedElevated = NeedElevated();

        if (bNeedElevated)  // should not happen
        {
            return FALSE;
        }

        BOOL bSucceed = FALSE;
        ULARGE_INTEGER uli;
        TCHAR szRegPath[1024];
        TaskDiscription taskDisc;

        ZeroMemory(&taskDisc, sizeof(taskDisc));
        uli.HighPart = (DWORD)wParam;
        uli.LowPart = (DWORD)lParam;

        GetTaskStorePath(uli, szRegPath, RTL_NUMBER_OF(szRegPath));

        if (RegGetString(HKEY_CURRENT_USER, szRegPath, TEXT("cmd"), taskDisc.szCommand, sizeof(taskDisc.szCommand)) &&
            RegGetString(HKEY_CURRENT_USER, szRegPath, TEXT("arg"), taskDisc.szArguments, sizeof(taskDisc.szArguments)) &&
            RegGetString(HKEY_CURRENT_USER, szRegPath, TEXT("dir"), taskDisc.szCurrentDirectory, sizeof(taskDisc.szCurrentDirectory)))
        {
            DWORD dwSize = sizeof(taskDisc.nShowCmd);

            SHGetValue(HKEY_CURRENT_USER, szRegPath, TEXT("sw"), NULL, &taskDisc.nShowCmd, &dwSize);

            bSucceed = (int)ShellExecute(NULL, TEXT("open"), taskDisc.szCommand, taskDisc.szArguments, taskDisc.szCurrentDirectory, taskDisc.nShowCmd) > 32;
        }

        SHDeleteKey(HKEY_CURRENT_USER, szRegPath);

        return bSucceed;
    }

    LRESULT CALLBACK WndProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
    {
        switch (uMsg)
        {
        case WM_CREATE:
            AddMessageToWindowMessageFilter(WM_TO_BRIDGE_INFO);
            return 0;

        case WM_TO_BRIDGE_INFO:
            DoBridgeJob(wParam, lParam);
            return 0;

        case WM_CLOSE:
            DestroyWindow(hWnd);
            return 0;

        case WM_DESTROY:
            PostQuitMessage(0);
            return 0;

        default:
            break;
        }

        return DefWindowProc(hWnd, uMsg, wParam, lParam);
    }

    void WINAPI SlxElevateBridgeW(HWND hwndStub, HINSTANCE hAppInstance, LPCWSTR lpszCmdLine, int nCmdShow)
    {
        if (IsWindow(GetBridgeHandle()) || lpszCmdLine == NULL || *lpszCmdLine == L'\0')
        {
            return;
        }

        LPCWSTR lpStr2 = StrStrW(lpszCmdLine, L" ");

        if (lpStr2 == NULL)
        {
            return;
        }
        else
        {
            lpStr2 += 1;
        }

        WNDCLASSEX wcex = { sizeof(wcex) };

        wcex.lpszClassName = CLASS_NAME;
        wcex.hInstance = g_hinstDll;
        wcex.lpfnWndProc = WndProc;
        wcex.style = CS_HREDRAW | CS_VREDRAW;
        wcex.cbClsExtra = 0;
        wcex.cbWndExtra = 0;
        wcex.hIcon = NULL;
        wcex.hCursor = LoadCursor(NULL, IDC_ARROW);
        wcex.hbrBackground = (HBRUSH)GetStockObject(WHITE_BRUSH);

        if (RegisterClassEx(&wcex))
        {
            HWND hWindow = CreateWindowEx(
                0,
                CLASS_NAME,
                BridgeVersion,
                WS_OVERLAPPEDWINDOW,
                CW_USEDEFAULT,
                CW_USEDEFAULT,
                CW_USEDEFAULT,
                CW_USEDEFAULT,
                NULL,
                NULL,
                g_hinstDll,
                NULL
                );

            if (IsWindow(hWindow))
            {
//                 ShowWindow(hWindow, SW_SHOW);
//                 UpdateWindow(hWindow);

                PostMessage(hWindow, WM_TO_BRIDGE_INFO, StrToIntW(lpszCmdLine), StrToIntW(lpStr2));

                MSG msg;

                while (TRUE)
                {
                    int nRet = GetMessage(&msg, NULL, 0, 0);

                    if (nRet <= 0)
                    {
                        break;
                    }

                    TranslateMessage(&msg);
                    DispatchMessage(&msg);
                }
            }
        }
    }
}